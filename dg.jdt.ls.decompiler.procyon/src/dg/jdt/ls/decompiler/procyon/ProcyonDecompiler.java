/*******************************************************************************
 * Copyright (c) 2022 David Gileadi.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     David Gileadi - initial API and implementation
 *******************************************************************************/
package dg.jdt.ls.decompiler.procyon;

import static org.eclipse.jdt.ls.core.internal.handlers.MapFlattener.getValue;

import java.io.StringWriter;
import java.net.URI;
import java.util.Map;

import dg.jdt.ls.decompiler.common.CachingDecompiler;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.Status;
import org.eclipse.jdt.core.IClassFile;
import org.eclipse.jdt.ls.core.internal.IDecompiler;
import org.eclipse.jdt.ls.core.internal.JDTUtils;
import org.eclipse.jdt.ls.core.internal.preferences.Preferences;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.strobel.assembler.InputTypeLoader;
import com.strobel.assembler.metadata.ClasspathTypeLoader;
import com.strobel.assembler.metadata.DeobfuscationUtilities;
import com.strobel.assembler.metadata.ITypeLoader;
import com.strobel.assembler.metadata.MetadataSystem;
import com.strobel.assembler.metadata.TypeDefinition;
import com.strobel.assembler.metadata.TypeReference;
import com.strobel.decompiler.DecompilationOptions;
import com.strobel.decompiler.DecompilerSettings;
import com.strobel.decompiler.PlainTextOutput;
import com.strobel.decompiler.languages.java.JavaFormattingOptions;

public class ProcyonDecompiler extends CachingDecompiler {

	public static final String OPTIONS_KEY = "java.decompiler.procyon";
	public static final String DECOMPILED_HEADER = " // Source code is unavailable, and was generated by the Procyon decompiler.\n";

	private DecompilerSettings settings = DecompilerSettings.javaDefaults();

	@SuppressWarnings("unchecked")
	@Override
	public void setPreferences(Preferences preferences) {
		Object options = getValue(preferences.asMap(), OPTIONS_KEY);
		if (options instanceof Map) {
			Map<String, Object> optionsMap = (Map<String, Object>) options;

			// prefix keys with '_'
			for (String key : optionsMap.keySet()) {
				if (!key.startsWith("_")) {
					optionsMap.put("_" + key, optionsMap.get(key));
					optionsMap.remove(key);
				}
			}

			Gson gson = new Gson();
			JsonElement jsonElement = gson.toJsonTree(optionsMap);
			settings = gson.fromJson(jsonElement, DecompilerSettings.class);
			settings.setJavaFormattingOptions(JavaFormattingOptions.createDefault());
			if (!((Map<?, ?>) options).containsKey("forceExplicitImports")) {
				settings.setForceExplicitImports(true);
			}
		}
	}

	@Override
	protected String decompileContent(URI uri, IProgressMonitor monitor) throws CoreException {
		IClassFile classFile = JDTUtils.resolveClassFile(uri);
		if (classFile != null) {
			return decompileContent(classFile, monitor);
		}

		String path = uri.getPath();
		return getContent(new InputTypeLoader(new ClasspathTypeLoader()), path, monitor);
	}

	@Override
	protected String decompileContent(IClassFile classFile, IProgressMonitor monitor) throws CoreException {
		return getContent(new JDTTypeLoader(classFile), JDTTypeLoader.FAKE_CLASS_NAME, monitor);
	}

	private String getContent(ITypeLoader typeLoader, String path, IProgressMonitor monitor) throws CoreException {
		settings.setTypeLoader(typeLoader);

		DecompilationOptions decompilationOptions = new DecompilationOptions();
		decompilationOptions.setSettings(settings);
		decompilationOptions.setFullDecompilation(true);

		MetadataSystem metadataSystem = new NoRetryMetadataSystem(decompilationOptions.getSettings().getTypeLoader());
		metadataSystem.setEagerMethodLoadingEnabled(false);

		if (typeLoader instanceof JDTTypeLoader) {
			((JDTTypeLoader) typeLoader).setMetadataResolver(metadataSystem);
		}

		TypeReference type = metadataSystem.lookupType(path);
		if (type == null) {
			return null;
		}
		TypeDefinition resolvedType = type.resolve();
		if (resolvedType == null) {
			return null;
		}

		DeobfuscationUtilities.processType(resolvedType);

		try {
			StringWriter writer = new StringWriter();
			PlainTextOutput output = new PlainTextOutput(writer);

			output.setUnicodeOutputEnabled(decompilationOptions.getSettings().isUnicodeOutputEnabled());

			decompilationOptions.getSettings().getLanguage().decompileType(resolvedType, output, decompilationOptions);

			writer.flush();
			writer.close();

			return DECOMPILED_HEADER + writer.toString();
		} catch (Throwable t) {
			throw new CoreException(new Status(Status.ERROR, "dg.jdt.ls.decompiler.cfr", "Error decompiling", t));
		}
	}
}
